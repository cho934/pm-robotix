#pragma config(Sensor, S4,     HTANG_LEFT,     sensorI2CCustom)
#pragma config(Sensor, S1,     HTANG_RIGHT,    sensorI2CCustom)
#pragma config(Motor,  motorC,          MOTOR_LEFT,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorA,          MOTOR_RIGHT,   tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma platform(NXT)

#ifndef _ODOMETRY
#define _ODOMETRY // prevent multiple compilations

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: ROBOTC PROJECT MAIN FILE DECLARATION
#ifndef PROJECT_MAIN_FILE
#define PROJECT_MAIN_FILE "codometry.c" //!< enable compilation of task main() and various debug and test functions of this file
#endif
// END OF:  ROBOTC PROJECT MAIN FILE DECLARATION
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: HEADERS
#include "codometry.h"
// END OF:  HEADERS
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: GLOBAL INSTANCES
// END OF:  GLOBAL INSTANCES
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: EXTERNAL SOURCES
#ifndef _MOTION_CALIBRATION
#include "cmotionCalibration.c"
#endif
// END OF:  EXTERNAL SOURCES
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: LOCAL INSTANCES
static float Theta;					//rad
static float cosTheta, sinTheta;	//no unit
static float xTops, yTops;		//encoder vTops
//static unsigned long odoPeriodNb = 0;
// END OF:  LOCAL INSTANCES
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: CODES

void odo_Integration(float dTheta, float dV)
{
	//float newCosTheta;
	//float newSinTheta;
	//int tempo;

	Theta += dTheta;

	if ( Theta > PI )
		Theta -= M_2PI;
	else if ( Theta <= -PI )
		Theta += M_2PI;

	//tempo = odoPeriodNb++ & 0x7F;

	//optimisation of the cos/sin computation :
	//every X integration period, we compute precise value for cosTheta and sinTheta
	//if(tempo == 0)
	//{
	//	newSinTheta = sinTheta+cosTheta*(dTheta);
	//	sinTheta = newSinTheta;

	//	//compute precise values for cos theta
	//	cosTheta = cos(Theta);//cosf
	//}
	//else if(tempo == 0x40)
	//{
	//	newCosTheta = cosTheta-sinTheta*(dTheta);
	//	cosTheta = newCosTheta;

	//	//compute precise values for sin theta
	//	sinTheta = sin(Theta);//sinf
	//}
	//else
	//{
	//	//taylor decomposition of cos(x) and sin(x) at second order for x ~= a is :
	//	//cos(a)-sin(a)*(x-a)+O(x-a)^2
	//	//sin(a)-cos(a)*(x-a)+O(x-a)^2
	//	newCosTheta = cosTheta-sinTheta*(dTheta);
	//	newSinTheta = sinTheta+cosTheta*(dTheta);

	//	cosTheta = newCosTheta;
	//	sinTheta = newSinTheta;
	//}

	cosTheta = cos(Theta);
	sinTheta = sin(Theta);

	xTops += dV*cosTheta;
	yTops += dV*sinTheta;
}

void odo_SetPosition(float x, float y, float theta)
{
	//convert position from meters to ticks
	xTops = x/valueVTops;
	yTops = y/valueVTops;
	Theta = theta;
	cosTheta = cos(Theta);//cosf
	sinTheta = sin(Theta);//sinf
}

void odo_GetPositionXYTheta(float *x, float *y, float *theta)
{
	if(x)
	{
		//convert position from ticks to meter
		*x = xTops * (float)valueVTops;
	}

	if(y)
	{
		//convert position from ticks to meter
		*y = yTops * (float)valueVTops;
	}

	if(theta)
	{
		*theta = Theta;
	}
}

//RobotPosition odo_GetPosition()
//{
//	RobotPosition pos;

//	//convert position from ticks to meter
//	pos.x = xTops * (float)valueVTops;
//	pos.y = yTops * (float)valueVTops;
//	pos.theta = Theta;

//	return pos;
//}

// END OF:  CODES
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: TESTS

#if(PROJECT_MAIN_FILE == "codometry.c")
	//-----------------------------------------------------------------------------------------------------------------------------
	//! @brief     this task tests the functions
	//! @return    none
	//! @author    cho
	//! @note
	//! @todo
	//-----------------------------------------------------------------------------------------------------------------------------
	task main()
	{


	}
#endif // (PROJECT_MAIN_FILE)

// END OF:  TESTS
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#endif
