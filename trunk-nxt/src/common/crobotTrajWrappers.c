#pragma config(Sensor, S4,     HTANG_LEFT,     sensorI2CCustom)
#pragma config(Sensor, S1,     HTANG_RIGHT,    sensorI2CCustom)
#pragma config(Motor,  motorC,          MOTOR_LEFT,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorA,          MOTOR_RIGHT,   tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma platform(NXT)

#ifndef _ROBOT_TRAJ_WRAPPERS
#define _ROBOT_TRAJ_WRAPPERS // prevent multiple compilations

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: ROBOTC PROJECT MAIN FILE DECLARATION
#ifndef PROJECT_MAIN_FILE
#define PROJECT_MAIN_FILE "crobotTrajWrappers.c" //!< enable compilation of task main() and various debug and test functions of this file
#endif
// END OF:  ROBOTC PROJECT MAIN FILE DECLARATION
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: HEADERS
#include "crobotTrajWrappers.h"
// END OF:  HEADERS
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: GLOBAL INSTANCES
// END OF:  GLOBAL INSTANCES
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: EXTERNAL SOURCES
#ifndef _MOTION
#include "cmotion.c"
#endif

// END OF:  EXTERNAL SOURCES
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: LOCAL INSTANCES
//static RobotCommand cmd;
// END OF:  LOCAL INSTANCES
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: CODES

TRAJ_STATE motion_DoLine(float dist)
{
	motion_Line(&motionCommand, dist);
	path_LaunchTrajectory(&motionCommand);
	return path_WaitEndOfTrajectory();
}

TRAJ_STATE motion_DoRotate(float angle)
{
	motion_Rotate(&motionCommand, angle);
	path_LaunchTrajectory(&motionCommand);
	return path_WaitEndOfTrajectory();
}

TRAJ_STATE motion_DoArcRotate(float angle, float radius)
{
	motion_ArcRotate(&motionCommand, angle, radius);
	path_LaunchTrajectory(&motionCommand);
	return path_WaitEndOfTrajectory();
}

void computeAlphaDelta(float x1, float y1, float theta1, float x2, float y2, float *out_angle, float *out_dist)
{
	float dx,dy;
	float dTheta;

	dx = x2 - x1;
	dy = y2 - y1;

	//s'il n'y a pas de deplacement a faire,
	//et bien on en fait pas...
	if(dx == 0.0 && dy == 0.0)
	{
		*out_angle = 0.0;
		*out_dist = 0.0;
		return;
	}

	//angle to run to reach position
	//dTheta = atan2f(dy,dx) - theta1;

	dTheta = math_atan2f(dy,dx) - theta1;

	//bound angle value to [-Pi ; Pi]
	if(dTheta < -PI)
		*out_angle = dTheta+M_2PI;
	else if(dTheta > PI)
		*out_angle = dTheta-M_2PI;
	else
		*out_angle = dTheta;

	//distance to run
	*out_dist = sqrt(dx*dx+dy*dy);
}

float math_atan2f(float y, float x)
{
	float absx, absy, val;
	if (x == 0 && y == 0)
	{
		return 0;
	}
	absy = y < 0 ? -y : y;
	absx = x < 0 ? -x : x;
	if (absy - absx == absy)
	{
		/* x negligible compared to y */
		return y < 0 ? -(PI/2) : (PI/2);
	}
	if (absx - absy == absx) {
		/* y negligible compared to x */
		val = 0.0;
	}
	else    val = atan(y/x);
	if (x > 0)
	{
		/* first or fourth quadrant; already correct */
		return val;
	}
	if (y < 0)
	{
		/* third quadrant */
		return val - PI;
	}
	return val + PI;
}


//http://www.raspberryginger.com/jbailey/minix/html/atan2_8c-source.html
//double
//00014 atan2(double y, double x)
//00015 {
//00016         double absx, absy, val;
//00017
//00018         if (x == 0 && y == 0) {
//00019                 //errno = EDOM;
//00020                 return 0;
//00021         }
//00022         absy = y < 0 ? -y : y;
//00023         absx = x < 0 ? -x : x;
//00024         if (absy - absx == absy) {
//00025                 /* x negligible compared to y */
//00026                 return y < 0 ? -M_PI_2 : M_PI_2;
//00027         }
//00028         if (absx - absy == absx) {
//00029                 /* y negligible compared to x */
//00030                 val = 0.0;
//00031         }
//00032         else    val = atan(y/x);
//00033         if (x > 0) {
//00034                 /* first or fourth quadrant; already correct */
//00035                 return val;
//00036         }
//00037         if (y < 0) {
//00038                 /* third quadrant */
//00039                 return val - M_PI;
//00040         }
//00041         return val + M_PI;
//00042 }

TRAJ_STATE motion_GoToSpeed(float x, float y)
{
	Position pos;
	pos.x = x;
	pos.y = y;

	return motion_GoToSpeedPath(&pos, 1);
}

TRAJ_STATE motion_GoToSpeedPath(Position *pos, int nb)
{
	TRAJ_STATE state;
	float spAlpha, spDelta;
	float x1, y1, theta1;
	float dist;
	float angle;
	int i=0;

	if(nb == 0)
		return TRAJ_OK;

	//compute displacement needed from current position
	pos_GetPositionXYTheta(&x1, &y1, &theta1);
	computeAlphaDelta(x1, y1, theta1, pos[i].x, pos[i].y, &angle, &dist);

	while(i<nb)
	{
		if((abs(angle) >= 0.5) || (dist >= 0.10))
		{
			spAlpha = angle/4.0;

			if(abs(angle) < 0.5)
				spDelta = 0.30;
			else if(dist <= 0.1)
				spDelta = 0.1;
			else
				spDelta = 0.0;

			if(spAlpha > 0.3)
				spAlpha = 0.3;
			else if(spAlpha < -0.3)
				spAlpha = -0.3;

			motion_SpeedControlADMaxTime(&motionCommand,
									spAlpha, 0.5,
									spDelta, 0.5,
									50);
			path_LaunchTrajectory(&motionCommand);

			//compute displacement needed from current position during waiting time
			pos_GetPositionXYTheta(&x1, &y1, &theta1);
			computeAlphaDelta(x1, y1, theta1, pos[i].x, pos[i].y, &angle, &dist);

			state = path_WaitEndOfTrajectory();
			if(state != TRAJ_OK)
			{
				motion_FreeMotion();
				return state;
			}
		}
		else
		{
			i++;

			if(i<nb)
			{
				//compute displacement
				pos_GetPositionXYTheta(&x1, &y1, &theta1);
				computeAlphaDelta(x1, y1, theta1, pos[i].x, pos[i].y, &angle, &dist);
			}
		}
	}

	motion_FreeMotion();
	return TRAJ_OK;
}

//TSL = Turn - Stop - Line
TRAJ_STATE motion_GoToTSLFrom(float x1, float y1, float theta1, float x2, float y2)
{
	TRAJ_STATE state;

	float dist;
	float angle;

	computeAlphaDelta(x1, y1, theta1, x2, y2, &angle, &dist);

	//rotation
	state = motion_DoRotate(angle);
	if(state != TRAJ_OK)
		return state;


	//line
	return motion_DoLine(dist);
}

TRAJ_STATE motion_GoToTSL(float x, float y)
{
	float x1;
	float y1;
	float theta1;

	pos_GetPositionXYTheta(&x1, &y1, &theta1);

	return motion_GoToTSLFrom(x1,y1,theta1, x,y);
}

TRAJ_STATE motion_OrientTo(float angle)
{
	float theta, dTheta;

	pos_GetPositionXYTheta(NULL, NULL, &theta);

	dTheta = angle - theta;

	//bound angle value to [-Pi ; Pi]
	if(dTheta < -PI)
		dTheta += M_2PI;
	else if(dTheta > PI)
		dTheta -= M_2PI;

	return motion_DoRotate(dTheta);
}
// END OF:  CODES
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: TESTS

#if(PROJECT_MAIN_FILE == "crobotTrajWrappers.c")
	//-----------------------------------------------------------------------------------------------------------------------------
	//! @brief     this task tests the functions
	//! @return    none
	//! @author    cho
	//! @note
	//! @todo
	//-----------------------------------------------------------------------------------------------------------------------------
	task main()
	{


	}
#endif // (PROJECT_MAIN_FILE)

// END OF:  TESTS
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#endif//_ROBOT_TRAJ_WRAPPERS
