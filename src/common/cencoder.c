#pragma config(Sensor, S4,     HTANG_LEFT,     sensorI2CCustom)
#pragma config(Sensor, S1,     HTANG_RIGHT,    sensorI2CCustom)
#pragma config(Motor,  motorC,          MOTOR_LEFT,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorA,          MOTOR_RIGHT,   tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#ifndef _ENCODER
#define _ENCODER // prevent multiple compilations

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: ROBOTC PROJECT MAIN FILE DECLARATION
#ifndef PROJECT_MAIN_FILE
#define PROJECT_MAIN_FILE "cencoder.c" //!< enable compilation of task main() and various debug and test functions of this file
#endif
// END OF:  ROBOTC PROJECT MAIN FILE DECLARATION
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: HEADERS
#include "cencoder.h"
// END OF:  HEADERS
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: GLOBAL INSTANCES
//ratio vTops/ticks for left encoder
long leftEncoderRatio = 0;
//ratio vTops/ticks for right encoder
long rightEncoderRatio = 0;
//distance between both encoder wheels in vTops
unsigned long distEncoder = 0;
//distance between both encoder wheels in meters
float distEncoderMeter = 0;
// END OF:  GLOBAL INSTANCES
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: EXTERNAL SOURCES
#ifndef _MOTION_CALIBRATION
#include "cmotionCalibration.c"
#endif
#ifndef _NXT
#include "cnxt.c"
#endif
// END OF:  EXTERNAL SOURCES
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: LOCAL INSTANCES
static long lastLeft = 0;
static long lastRight = 0;
// END OF:  LOCAL INSTANCES
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: CODES

void encoder_Init()
{
	lastLeft = 0;
	lastRight = 0;

	//reset encoder
	nxt_ResetMotorEncoder();
}

void encoder_SetDist(float dist)
{
	distEncoderMeter = dist;
	distEncoder = dist / valueVTops;
	#if(LEVEL_ENCODER <= DEBUG)
	writeDebugStreamLine("cencoder.c distEMeter=%f[m], distE=%d[vTops], valueVTops=%.10f[m/vTops]", distEncoderMeter, distEncoder, valueVTops);
	#endif
}

void encoder_SetResolution(long leftTicksPerM, long rightTicksPerM)
{
	if(leftTicksPerM > rightTicksPerM)
	{
		leftEncoderRatio = VTOPS_PER_TICKS;
		rightEncoderRatio = VTOPS_PER_TICKS * rightTicksPerM/(float)leftTicksPerM;
		valueVTops = 1.0/(float)(VTOPS_PER_TICKS * leftTicksPerM);
		#if(LEVEL_ENCODER <= INFO)
		writeDebugStreamLine("cencoder.c LTicksPerM > RTicksPerM : valueVTops=%.10f[m/vTops]", valueVTops);
		#endif
	}
	else
	{
		leftEncoderRatio = VTOPS_PER_TICKS * leftTicksPerM/(float)rightTicksPerM;
		rightEncoderRatio = VTOPS_PER_TICKS;
		valueVTops = 1.0/(float)(VTOPS_PER_TICKS * rightTicksPerM);
		#if(LEVEL_ENCODER <= INFO)
		writeDebugStreamLine("cencoder.c LTicksPerM <= RTicksPerM : valueVTops=%.10f[m/vTops]", valueVTops);
		#endif
	}

	//recompute values involving vTops
	encoder_SetDist(distEncoderMeter);
}

void encoder_ReadSensor(long *dLeft, long *dRight, long *dAlpha, long *dDelta)
{
	//static float dTheta;
	//static float dV;
	static long left = 0, right = 0;

	//read encoder
	left = nxt_ReadMotorEncoderLeft(); //[ticks]
	right = nxt_ReadMotorEncoderRight(); //[ticks]

	//convert units to vTops and save position
	left *= leftEncoderRatio; //=VTOPS_PER_TICKS
	right *= rightEncoderRatio;

	//compute delta for left wheel
	*dLeft = left - lastLeft;
	lastLeft = left;
	//verify left encoder overflow
	//CORRECT_DELTA_OVERFLOW(*dLeft, MAX_ENCODER_ABS_VTOPS); //TODO comprend pas !!
	//#define CORRECT_DELTA_OVERFLOW(value, max_value) {if((value)>(max_value/2))value-=max_value; else if((value)<(-(max_value/2)))value+=max_value;}


	//compute delta for right wheel
	*dRight = right - lastRight;
	lastRight = right;
	//verify right encoder overflow
	//CORRECT_DELTA_OVERFLOW(*dRight, MAX_ENCODER_ABS_VTOPS);

	//compute alpha and delta displacement
	*dAlpha = (*dRight-*dLeft)/2;
	*dDelta = (*dRight+*dLeft)/2;
}


// END OF:  CODES
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: TESTS

#if(PROJECT_MAIN_FILE == "cencoder.c")
	//-----------------------------------------------------------------------------------------------------------------------------
	//! @brief     this task tests the functions
	//! @return    none
	//! @author    cho
	//! @note
	//! @todo
	//-----------------------------------------------------------------------------------------------------------------------------
	task main()
	{
		nxt_InitPIDSpeedCtrl();

		static long dLeft = 0, dRight = 0;
		static long dAlpha = 0, dDelta = 0;

		static long left = 0, right = 0;

		//reset encoder
		encoder_Init();
		encoder_SetDist(0.137); //meter

		long nbTickPerMeterL = 1446;//1446
		long nbTickPerMeterR = 1446;//1446
		int pwm = 8;
		int forward = -1; //1 ou -1

		//configure encoder
		//DIST_PER_TICK = 1.0*WHEEL_DIAMETER80*PI/360.0 = 0.69813 //mm
		encoder_SetResolution(nbTickPerMeterL, nbTickPerMeterR); //tickPerMeter

		long destL = nbTickPerMeterL /2; //50mm
		long destR = nbTickPerMeterR /2; //50mm
		#if(LEVEL_ENCODER <= INFO)
		writeDebugStreamLine("cencoder.c Go to 50mm : destL=%d destR=%d [Ticks]", destL, destR);
		#endif

		setPWM (pwm * forward, pwm * forward);

		while((abs(left)<=destL) || (abs(right)<=destR) )
		{

			left = nxt_ReadMotorEncoderLeft();
			right = nxt_ReadMotorEncoderRight();
			encoder_ReadSensor(&dLeft,&dRight,&dAlpha,&dDelta);
			#if(LEVEL_ENCODER <= INFO)
			writeDebugStreamLine("cencoder.c left;%d;right;%d", left, right);
			writeDebugStreamLine("dLeft:%d, dRight:%d, dAlpha:%d, dDelta:%d", dLeft, dRight, dAlpha, dDelta);
			#endif

			if((abs(left)>=destL))
			{
				setPWM (0, (pwm-4) * forward);
				#if(LEVEL_ENCODER <= INFO)
				writeDebugStreamLine("cencoder.c left=0");
				#endif
			}
			if((abs(right)>=destR))
			{
				setPWM ((pwm-4) * forward, 0);
				#if(LEVEL_ENCODER <= INFO)
				writeDebugStreamLine("cencoder.c right=0");
				#endif
			}

			Sleep(15);
		}
		setPWM (0, 0);
		Sleep(800);
		left = nxt_ReadMotorEncoderLeft();
		right = nxt_ReadMotorEncoderRight();
		#if(LEVEL_ENCODER <= INFO)
		writeDebugStreamLine("cencoder.c END left;%d;right;%d", left, right);
		#endif

	}
#endif // (PROJECT_MAIN_FILE)

// END OF:  TESTS
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#endif
