#pragma config(Sensor, S4,     HTANG_LEFT,     sensorI2CCustom)
#pragma config(Sensor, S1,     HTANG_RIGHT,    sensorI2CCustom)
#pragma config(Motor,  motorC,          MOTOR_LEFT,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorA,          MOTOR_RIGHT,   tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma platform(NXT)

#ifndef _MOTION_CALIBRATION
#define _MOTION_CALIBRATION // prevent multiple compilations

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: ROBOTC PROJECT MAIN FILE DECLARATION
#ifndef PROJECT_MAIN_FILE
#define PROJECT_MAIN_FILE "cmotionCalibration.c" //!< enable compilation of task main() and various debug and test functions of this file
#endif
// END OF:  ROBOTC PROJECT MAIN FILE DECLARATION
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: HEADERS
#ifndef _MOTION_CALIBRATION_H_
#include "cmotionCalibration.h"
#endif
// END OF:  HEADERS
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: GLOBAL INSTANCES
//! what kind of sensor do we use for odometry
ODOMETRY_SENSOR odometrySensorUsed;
////! should we send error on the UART (for debug and calibration purpose)
//bool isSendErrorsEnabled;
//! how much slippage should trigger an alarm
long slippageThreshold;
//! value of a vTops in meter (ratio for 'major wheel')
float valueVTops = 0.0; //	[meter/vTops]
//! value of a sample in second
float valueSample = 0.0; // [sec/sample]
// END OF:  GLOBAL INSTANCES
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: EXTERNAL SOURCES
#ifndef _MOTOR
#include "cmotor.c"
#endif
#ifndef _ENCODER
#include "cencoder.c"
#endif
#ifndef _ENCODER
#include "cencoderExtern.c"
#endif
// END OF:  EXTERNAL SOURCES
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: LOCAL INSTANCES
//default values
static float defSpeed = DEFAULT_SPEED;	//robot speed
static float defAccel = DEFAULT_ACCEL; //robot acceleration
static float defDecel = DEFAULT_DECEL; //robot deceleration
//static int calibStep = 0;
// END OF:  LOCAL INSTANCES
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: CODES

void motion_SetSamplingFrequency(int periodMs)
{
	//valueSample = 1 / (float)freq;
	valueSample = (float)periodMs / 1000.0; // [sec/sample]

	#if(LEVEL_MOTIONCALIBRATION <= INFO)
	writeDebugStreamLine("cmotionCalib.c motion_SetSamplingFrequency: valueSample=%f [sec/sample]", valueSample);
	#endif

	//need a recomputation of all values involving sampling time
	// kP/kI/kD/dPeriod
	// speed/acceleration

	// Set up Timer A0 Reload Register for x msec interval
	//ta0 = CPU_CLK_FREQ/(freq*8);
}


void motion_CalibrationInit(void)
{
	//REGISTER_LOG_CLIENT("MOTION");

	//mtxDefaultSpeeds = OSMutexCreate(DEF_SPEED_MTX_PRIO, &OSLastError);
	//LOG_TEST_OS_ERROR(OSLastError);

	encoder_SetDist(DEFAULT_ENCODER_DIST);
	encoder_SetResolution(DEFAULT_LEFT_TICKS_PER_M, DEFAULT_RIGHT_TICKS_PER_M);

	slippageThreshold = DEFAULT_SLIPPAGE;

	//isSendErrorsEnabled = false;

	odometrySensorUsed = MOTOR_ENCODER; //MOTOR_ENCODER ou autre

	//pid_ConfigKP(motors[ALPHA_DELTA][ALPHA_MOTOR].PIDSys, 500);
	//pid_ConfigKI(motors[ALPHA_DELTA][ALPHA_MOTOR].PIDSys, 0);
	//pid_ConfigKD(motors[ALPHA_DELTA][ALPHA_MOTOR].PIDSys, 0);
	//pid_ConfigDPeriod(motors[ALPHA_DELTA][ALPHA_MOTOR].PIDSys, 3);
	//pid_ConfigKP(motors[ALPHA_DELTA][DELTA_MOTOR].PIDSys, 500);
	//pid_ConfigKI(motors[ALPHA_DELTA][DELTA_MOTOR].PIDSys, 0);
	//pid_ConfigKD(motors[ALPHA_DELTA][DELTA_MOTOR].PIDSys, 0);
	//pid_ConfigDPeriod(motors[ALPHA_DELTA][DELTA_MOTOR].PIDSys, 3);
	//pid_ConfigKP(motors[LEFT_RIGHT][LEFT_MOTOR].PIDSys, 2500);
	//pid_ConfigKP(motors[LEFT_RIGHT][RIGHT_MOTOR].PIDSys, 2500);


		pid_ConfigKP(motors[ALPHA_DELTA][ALPHA_MOTOR].PIDSys, 800);
		pid_ConfigKI(motors[ALPHA_DELTA][ALPHA_MOTOR].PIDSys, 0);
		pid_ConfigKD(motors[ALPHA_DELTA][ALPHA_MOTOR].PIDSys, 400);
		pid_ConfigDPeriod(motors[ALPHA_DELTA][ALPHA_MOTOR].PIDSys, 3);
		pid_ConfigKP(motors[ALPHA_DELTA][DELTA_MOTOR].PIDSys, 500);
		pid_ConfigKI(motors[ALPHA_DELTA][DELTA_MOTOR].PIDSys, 0);
		pid_ConfigKD(motors[ALPHA_DELTA][DELTA_MOTOR].PIDSys, 500);
		pid_ConfigDPeriod(motors[ALPHA_DELTA][DELTA_MOTOR].PIDSys, 3);

		pid_ConfigKP(motors[LEFT_RIGHT][LEFT_MOTOR].PIDSys, 75);
		pid_ConfigKI(motors[LEFT_RIGHT][LEFT_MOTOR].PIDSys, 0);
		pid_ConfigKD(motors[LEFT_RIGHT][LEFT_MOTOR].PIDSys, 50);
		pid_ConfigKP(motors[LEFT_RIGHT][RIGHT_MOTOR].PIDSys, 75);
		pid_ConfigKI(motors[LEFT_RIGHT][RIGHT_MOTOR].PIDSys, 5);
		pid_ConfigKD(motors[LEFT_RIGHT][RIGHT_MOTOR].PIDSys, 50);
		motors_ConfigAllIMax(90000);

	////register handlers
	//protocol_SetHandler(M32_WHEEL_PID_TUNING, motion_wheelPIDTuning_handler);
	//protocol_SetHandler(M32_ALPHADELTA_PID_TUNING, motion_alphaDeltaPIDTuning_handler);
	//protocol_SetHandler(M32_ODOMETRY_TUNING, motion_odometryTuning_handler);
}

void motion_SetDefaultSpeed(float speed)
{
	//int i;
	//BOOL found = FALSE;

	//OSMutexPend(mtxDefaultSpeeds, 0, &OSLastError);
	//LOG_TEST_OS_ERROR(OSLastError);

	defSpeed = speed;

	////find appropriate speed and set mouse resolution
	//for(i=0; i<CALIB_SPEED_NB; i++)
	//{
	//	if(speed == calibSpeed[i])
	//	{
	//		encoder_SetResolution(calibMouse[i][0], calibMouse[i][1]);
	//		found = TRUE;
	//		break;
	//	}
	//}

	//motors_ConfigAllIMax(SLIPPAGE_RATIO * MAX(speed, 0.3));


	//if(!found)
	//{
	//encoder_SetResolution(DEFAULT_LEFT_TICKS_PER_M, DEFAULT_RIGHT_TICKS_PER_M);
	//}

	//OSMutexPost(mtxDefaultSpeeds);
}

float motion_GetDefaultSpeed()
{
	float speed;
	//OSMutexPend(mtxDefaultSpeeds, 0, &OSLastError);
	//LOG_TEST_OS_ERROR(OSLastError);

	speed = defSpeed;

	//OSMutexPost(mtxDefaultSpeeds);

	return speed;
}

void motion_SetDefaultAccel(float accel)
{
	//OSMutexPend(mtxDefaultSpeeds, 0, &OSLastError);
	//LOG_TEST_OS_ERROR(OSLastError);

	defAccel = accel;

	//OSMutexPost(mtxDefaultSpeeds);
}

float motion_GetDefaultAccel()
{
	float accel;
	//OSMutexPend(mtxDefaultSpeeds, 0, &OSLastError);
	//LOG_TEST_OS_ERROR(OSLastError);

	accel = defAccel;

	//OSMutexPost(mtxDefaultSpeeds);

	return accel;
}

void motion_SetDefaultDecel(float decel)
{
	//OSMutexPend(mtxDefaultSpeeds, 0, &OSLastError);
	//LOG_TEST_OS_ERROR(OSLastError);

	defDecel = decel;

	//OSMutexPost(mtxDefaultSpeeds);
}

float motion_GetDefaultDecel()
{
	float decel;
	//OSMutexPend(mtxDefaultSpeeds, 0, &OSLastError);
	//LOG_TEST_OS_ERROR(OSLastError);

	decel = defDecel;

	//OSMutexPost(mtxDefaultSpeeds);

	return decel;
}

// END OF:  CODES
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// SECTION: TESTS

#if(PROJECT_MAIN_FILE == "cmotionCalibration.c")
	//-----------------------------------------------------------------------------------------------------------------------------
	//! @brief     this task tests the functions
	//! @return    none
	//! @author    cho
	//! @note
	//! @todo
	//-----------------------------------------------------------------------------------------------------------------------------
	task main()
	{


	}
#endif // (PROJECT_MAIN_FILE)

// END OF:  TESTS
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#endif
